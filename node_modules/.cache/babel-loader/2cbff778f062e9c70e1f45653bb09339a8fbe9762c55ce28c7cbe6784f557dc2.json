{"ast":null,"code":"// index.ts\nimport { booleanDisjoint } from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\nfunction booleanIntersects(feature1, feature2, options = {}) {\n  var _a;\n  const ignoreSelfIntersections = (_a = options.ignoreSelfIntersections) != null ? _a : false;\n  let bool = false;\n  flattenEach(feature1, flatten1 => {\n    flattenEach(feature2, flatten2 => {\n      if (bool === true) {\n        return true;\n      }\n      bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry, {\n        ignoreSelfIntersections\n      });\n    });\n  });\n  return bool;\n}\nvar turf_boolean_intersects_default = booleanIntersects;\nexport { booleanIntersects, turf_boolean_intersects_default as default };","map":{"version":3,"names":["booleanDisjoint","flattenEach","booleanIntersects","feature1","feature2","options","_a","ignoreSelfIntersections","bool","flatten1","flatten2","geometry","turf_boolean_intersects_default"],"sources":["/root/tesis/gps/node_modules/@turf/boolean-intersects/index.ts"],"sourcesContent":["import { Feature, Geometry } from \"geojson\";\nimport { booleanDisjoint } from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\n\n/**\n * Boolean-intersects returns (TRUE) if the intersection of the two geometries is NOT an empty set.\n *\n * @name booleanIntersects\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreSelfIntersections=false] ignores self-intersections on input features\n * @returns {boolean} true if geometries intersect, false otherwise\n * @example\n * var point1 = turf.point([2, 2]);\n * var point2 = turf.point([1, 2]);\n * var line = turf.lineString([[1, 1], [1, 3], [1, 4]]);\n *\n * turf.booleanIntersects(line, point1);\n * //=false\n *\n * turf.booleanIntersects(line, point2);\n * //=true\n *\n * //addToMap\n * var addToMap = [point1, point2, line];\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n */\nfunction booleanIntersects(\n  feature1: Feature<any> | Geometry,\n  feature2: Feature<any> | Geometry,\n  options: {\n    ignoreSelfIntersections?: boolean;\n  } = {}\n) {\n  const ignoreSelfIntersections: boolean =\n    options.ignoreSelfIntersections ?? false;\n\n  let bool = false;\n  flattenEach(feature1, (flatten1) => {\n    flattenEach(feature2, (flatten2) => {\n      if (bool === true) {\n        return true;\n      }\n      bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry, {\n        ignoreSelfIntersections,\n      });\n    });\n  });\n  return bool;\n}\n\nexport { booleanIntersects };\nexport default booleanIntersects;\n"],"mappings":";AACA,SAASA,eAAA,QAAuB;AAChC,SAASC,WAAA,QAAmB;AA2B5B,SAASC,kBACPC,QAAA,EACAC,QAAA,EACAC,OAAA,GAEI,CAAC,GACL;EAnCF,IAAAC,EAAA;EAoCE,MAAMC,uBAAA,IACJD,EAAA,GAAAD,OAAA,CAAQE,uBAAA,KAAR,OAAAD,EAAA,GAAmC;EAErC,IAAIE,IAAA,GAAO;EACXP,WAAA,CAAYE,QAAA,EAAWM,QAAA,IAAa;IAClCR,WAAA,CAAYG,QAAA,EAAWM,QAAA,IAAa;MAClC,IAAIF,IAAA,KAAS,MAAM;QACjB,OAAO;MACT;MACAA,IAAA,GAAO,CAACR,eAAA,CAAgBS,QAAA,CAASE,QAAA,EAAUD,QAAA,CAASC,QAAA,EAAU;QAC5DJ;MACF,CAAC;IACH,CAAC;EACH,CAAC;EACD,OAAOC,IAAA;AACT;AAGA,IAAOI,+BAAA,GAAQV,iBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}